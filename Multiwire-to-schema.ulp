string preamble = "edit .sch\nset Warning.PartHasNoUserDefinableValue 0\nset wire_bend 2\ngrid mm\nedit .s1\nchange layer 91\nchange style continuous\n";
string postamble = "set Warning.PartHasNoUserDefinableValue 1\nwindow fit\ngrid last\n";

string wires[];
int nWires;

real dist(UL_PIN p0, UL_PIN p1) {
    // Pythagoras is our friend
    real dx = p0.x - p1.x;
    real dy = p0.y - p1.y;
    return sqrt(dx * dx + dy * dy);
}

/* Working set */
string instances[];
string pin_names[];
UL_PIN pins[];

/**
 * Finds the pins corresponding to a single net
 *
 * Input:
 *  instances[0]..instances[count-1]: Instance names, e.g. "C1"
 *  pin_names[0]..pin_names[count-1]: Pin names, e.g. "1"
 * Output:
 *  pins[0]..pins[count-1]: Pins as found
 * Returns the number of pins found.
 */
int find_pins(int count)
{
    int found = 0;
    schematic(S) {
        S.sheets(SH) {
            SH.instances(I) {
                /* For each instance, check all names in this net */
                for (int i = 0; i < count; i++) {
                    if (I.name == instances[i]) {
                        printf("### Instance %s\n", I.name);
                        /* Found the instance.  Now find the pin with the corresponding contact name. */
                        I.gate.symbol.pins(P) {
                            P.contacts(C) {
                                if (C.name == pin_names[i]) {
                                    printf("### Pin %s\n", P.name);
                                    pins[i] = P;
                                    found++;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                }
                if (found == count)
                    /* Found all instances, terminate early */
                    return count;
            }
        }
    }
    return found;
}

/*
 * Draws a net.
 *
 * Starts from the first pin, and always adding the pin that is
 * closest the any of the ones already included.
 *
 * Inputs:
 *  instances[0]..instances[count-1]: Instance names, e.g. "C1"
 *  pin_names[0]..pin_names[count-1]: Pin names, e.g. "1"
 * Outputs:
 *  Eagle script commands written to the output
 */
void draw_net(string net, int count)
{
    int found = find_pins(count);
    if (found < count) {
        printf("### Couldn't find all parts...skipping\n");
        return;
    }

    for (int i = 0; i < count; i++) {
        /*
          Find the closest pair where
           - one pin is in the already found, 0...i,
           - one pin is a new one, i+1...count-1,
        */
        UL_PIN p0;
        UL_PIN p1;
        real d = REAL_MAX;
        int k0 = i+1;
        for (int j = 0; j <= i; j++) {
            for (int k = i+1; k < count; k++) {
                real d2 = dist(pins[j], pins[k]);
                if (d2 < d) {
                    p0 = pins[j]; p1 = pins[k]; d = d2; k0 = k;
                }
            }
        }

        /* Add the wire */
        printf("net '%s' (r %f %f) (r %f %f)\n",
               net,
               u2mm(p0.x), u2mm(p0.y),
               u2mm(p1.x), u2mm(p1.y));

        /* Swap the second pin to the found pins area */
        pins[k0] = pins[i+1];
        pins[i+1] = p1;
    }

}

sort(nWires, wires);

nWires = 
    fileread(wires, "/Users/pnr/Documents/eagle/BOM-import/PAHKA-ETH2multiwir.NET.txt");

output("/Users/pnr/Documents/eagle/BOM-import/Elli-proto.net.scr") {
    string prev_net = "";
    int count = 0, start = 0;

    printf("%s", preamble);
    for (int i = 0; i < nWires; i++) {
        if (wires[i][0] == '#')
            continue;
        string fields[];
        int num = strsplit(fields, wires[i], '\t');
        if (num != 3)
            continue;
        if (prev_net != fields[0]) {
            /* Draw the previous net */
            printf("## Net %s: start at %d, %d pins\n", prev_net, start, count);
            if (count > 1) {
                draw_net(prev_net, count);
            }
            prev_net = fields[0];
            count = 0;
            start = i;
        }

        /* Accumulate parts */
        instances[count] = fields[1];
        pin_names[count] = fields[2];
        count++;
    }
    if (count != 0) {
        draw_net(prev_net, count);
    }
}
